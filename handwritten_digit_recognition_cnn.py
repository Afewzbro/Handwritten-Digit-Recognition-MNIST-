# -*- coding: utf-8 -*-
"""Handwritten_Digit_Recognition_CNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1c4Lnua-sMuF9ocYn2GZZ16vDOc8Lh38r
"""

!pip install --upgrade tensorflow

# Importing necessary libraries:
import tensorflow as tf
from tensorflow.keras.datasets import mnist
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Flatten
from tensorflow.keras.layers import Conv2D, MaxPooling2D, BatchNormalization
import matplotlib.pyplot as plt

# Load the MNIST dataset
(x_train, y_train), (x_test, y_test) = mnist.load_data()

# Reshape the dataset to format which the model expects
x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)
x_test = x_test.reshape(x_test.shape[0], 28, 28, 1)

# Normalizing RGB codes by dividing it to the max RGB value
x_train = x_train / 255
x_test = x_test / 255

# Convert labels to one hot vectors
y_train = tf.keras.utils.to_categorical(y_train, 10)
y_test = tf.keras.utils.to_categorical(y_test, 10)

# Creating the model architecture:

model = Sequential()
model.add(Conv2D(32, kernel_size=(3, 3), activation='relu', input_shape=(28, 28, 1)))
model.add(BatchNormalization())
model.add(Conv2D(32, kernel_size=(3, 3), activation='relu'))
model.add(BatchNormalization())
model.add(Conv2D(32, kernel_size=(5, 5), strides=2, padding='same', activation='relu'))
model.add(BatchNormalization())
model.add(Dropout(0.4))

model.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))
model.add(BatchNormalization())
model.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))
model.add(BatchNormalization())
model.add(Conv2D(64, kernel_size=(5, 5), strides=2, padding='same', activation='relu'))
model.add(BatchNormalization())
model.add(Dropout(0.4))

model.add(Flatten())
model.add(Dense(128, activation='relu'))
model.add(BatchNormalization())
model.add(Dropout(0.4))
model.add(Dense(10, activation='softmax')) # 10 because we have 10 digits

# Compiling and training the model:

model.compile(loss=tf.keras.losses.categorical_crossentropy,
              optimizer=tf.keras.optimizers.Adam(),
              metrics=['accuracy'])

model.fit(x_train, y_train,
          batch_size=128,
          epochs=30,
          verbose=1,
          validation_data=(x_test, y_test))
model.compile(loss=tf.keras.losses.categorical_crossentropy,
              optimizer=tf.keras.optimizers.Adam(),
              metrics=['accuracy'])

model.fit(x_train, y_train,
          batch_size=128,
          epochs=30,
          verbose=1,
          validation_data=(x_test, y_test))

# Evaluating the model:

score = model.evaluate(x_test, y_test, verbose=0)
print('Test loss:', score[0])
print('Test accuracy:', score[1])

# Predict on the test data:

predictions = model.predict(x_test)

# Predict on the test data:

predicted_classes = tf.argmax(predictions, axis=1)

# Visualize the predictions:

import matplotlib.pyplot as plt
import numpy as np

# Choose random images to display
indices = np.random.choice(range(x_test.shape[0]), size=5, replace=False)

for i, idx in enumerate(indices):
    plt.figure(i)
    plt.imshow(x_test[idx].reshape(28, 28), cmap='gray')
    plt.title(f"True label: {np.argmax(y_test[idx])} Predicted: {predicted_classes[idx]}")
    plt.axis('off')
plt.show()

from sklearn.metrics import confusion_matrix
import seaborn as sns

# We need to convert the one-hot vectors back to single digit labels
y_true = np.argmax(y_test, axis=1)

conf_mat = confusion_matrix(y_true, predicted_classes)

plt.figure(figsize=(10, 10))
sns.heatmap(conf_mat, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted label')
plt.ylabel('True label')
plt.show()

import cv2
import matplotlib.pyplot as plt

# Replace 'your_image.png' with the name of the uploaded image file
img = cv2.imread('WhatsApp Image 2023-07-16 at 08.28.28.jpeg', cv2.IMREAD_GRAYSCALE)

# Display the image
plt.imshow(img, cmap='gray')
plt.show()

import cv2

# Load the image
image = cv2.imread('WhatsApp Image 2023-07-16 at 08.28.28.jpeg', cv2.IMREAD_GRAYSCALE)

# Resize it to 28x28 pixels
image = cv2.resize(image, (28, 28))

# Invert colors (optional, depending on your image)
image = cv2.bitwise_not(image)

# Normalize pixel values to [0, 1]
image = image / 255.0

# Reshape the image to the format expected by the model
image = image.reshape(1, 28, 28, 1)

prediction = model.predict(image)

# The prediction is a 10-element vector of probabilities.
# To get the predicted digit, take the index of the highest probability.
predicted_digit = np.argmax(prediction)

print('The predicted digit is:', predicted_digit)